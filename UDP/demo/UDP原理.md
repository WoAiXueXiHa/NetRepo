# UDP 网络编程深度解析

## 一、 通信基石：五元组与端口
### 1. 五元组 (唯一标识一个通信)
- **源IP**: 发送方地址
- **源端口号**: 发送方进程标识
- **目的IP**: 接收方地址
- **目的端口号**: 接收方进程标识
- **协议号**: TCP 或 UDP
- *命令*: `netstat -n` 查看

### 2. 端口号划分
- **知名端口 (Well-Known)**: `0 ~ 1023` (如 HTTP 80, SSH 22)
- **私有端口 (Ephemeral)**: `1024 ~ 65535` (OS 动态分配给客户端)

### 3. 端口绑定规则 (面试高频)
- **进程 -> 端口**:
    - **可以绑定多个**: 一个进程可以通过创建多个 Socket 绑定不同端口。
- **端口 -> 进程**:
    - **默认**: **不行** (报 "Address already in use")。
    - **特例**: 使用 `setsockopt` 设置 `SO_REUSEADDR` 或 `SO_REUSEPORT` 可实现多进程绑定同一端口。

## 二、 UDP 协议解剖 (底层原理)
### 1. 报文结构 (固定 8 字节头部)
- **源端口号 (16位)**
- **目的端口号 (16位)**: 核心作用 -> **分用** (OS 根据此字段推送到对应进程缓冲区)。
- **UDP长度 (16位)**:
    - **限制**: 最大 65535 字节 (64KB)。
    - **痛点**: 大于 64KB 数据**必须在应用层手动分包**。
- **校验和 (16位)**: 出错直接丢弃。
- *解包原理*: OS 读取前 8 字节解析，指针偏移 8 字节后即为有效载荷。

### 2. 核心特点 (与 TCP 对比)
- **面向数据报**:
    - **定义**: 不拆分、不合并，原样转发 (保留消息边界)。
    - **接收端**: 必须一次性读完一个包，否则可能截断/丢弃。
- **无连接**:
    - 知道 IP:Port 直接发，无需三次握手。
- **不可靠**:
    - 无确认 (ACK)、无重传。
    - 网络故障时不返回错误信息。

### 3. 缓冲区机制
- **发送缓冲区**: **不存在** (直接交给内核 -> 网卡)。
- **接收缓冲区**: **存在**。
    - **乱序**: 不保证顺序。
    - **丢包**: 缓冲区满则直接丢弃新数据。

## 三、 C++ Socket 编程实践
### 1. 服务端 (Server) 流程
1.  **socket()**: 创建套接字 (`AF_INET`, `SOCK_DGRAM`).
2.  **bind()**: **必须绑定**。
    - `INADDR_ANY`: 监听本机所有网卡。
    - `htons(PORT)`: 主机字节序转网络字节序。
3.  **recvfrom()**: **核心阻塞点**。
    - *参数*: 接收缓冲区、**输出型参数** (存发送方地址)。
    - *返回值 0*: **收到空包** (不同于 TCP 的断开连接)。
    - *注意*: 字符串手动补 `\0`。
4.  **sendto()**: 回包。
    - 利用 `recvfrom` 拿到的地址直接发回。

### 2. 客户端 (Client) 流程
1.  **socket()**: 创建套接字。
2.  **无需 bind()**: OS 自动分配随机端口 (隐式绑定)。
3.  **sendto()**: **直接发送**。
    - 必须指定目标 Server 的 IP 和 Port。
4.  **recvfrom()**: 等待回信。

### 3. 关键代码细节 (避坑指南)
- **头文件**: `<sys/socket.h>`, `<arpa/inet.h>`
- **memset**: 初始化地址结构体为 0。
- **socklen_t**: `recvfrom` 的最后一个参数是**指针** (值-结果参数)。
- **sendto/recvfrom**: UDP 专用的 IO 函数 (虽也可用 read/write 但不推荐)。